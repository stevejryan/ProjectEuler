
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>HtsVignette_sub</title><meta name="generator" content="MATLAB 9.1"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2020-05-08"><meta name="DC.source" content="HtsVignette_sub.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#2">Summary</a></li><li><a href="#3">%%%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%%</a></li><li><a href="#4">%%%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%%</a></li><li><a href="#5">1.1 Pass in a feature table you've already got.</a></li><li><a href="#6">1.2 Request a feature table from OptoDB as a part of HTS analysis</a></li><li><a href="#7">1.3 Passing in an analyses object to do a time-bin analysis</a></li><li><a href="#8">%%%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%%</a></li><li><a href="#9">%%%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%%</a></li><li><a href="#10">2.1 Requesting multiple existing features using _SelectColumns()</a></li><li><a href="#11">%%%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%%</a></li><li><a href="#12">%%%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%%</a></li><li><a href="#13">3.1 - on-plate NPI</a></li></ul></div><pre class="codeinput"><span class="comment">% HtsVignette.m</span>
</pre><h2 id="2">Summary</h2><p>This document will outline the major features and functionality of the code-base developed at Q-State for the analysis of high-throughput screening data.  First I'll give a short narrative description of the major modules, and that will be followed by a series of examples outlining how major features are intended to be used.</p><p>In keeping with Q-State's historically boring (and descriptive) naming scheme, the primary function to call for generating HTS analyses is AnalyzeHts().  This pipeline was designed and built with HTS data in mind, but has turned out to be useful for a variety of phenotyping and drug-discovery analysis needs.  The basic design principle is to specify a set of disease scores, normalize them to any existing controls, and then generate plots for every specified score.</p><p>Below is a high-level diagram of the AnalyzeHts() pipeline.  Briefly, 1. You give it some data (or tell it where to find said data), which it    cleans up and aggregates to the requested level (ie, by default a    source-feature table gets aggregated to the well level, since most    screens are presumed to operate at the well level) 2. It computes the descriptive scores you have requested (more detail on    this in HtsScoringVignette.m, but this could be anything from a single    feature, like Rheobase, to multi-parameter LDA scores, to automated    vector-decomposition or PCA-based scores). 3. These scores are optionally normalized and converted into 'hit scores'    (more information on this in HtsNormalizationVignette.m) 4. All scores are stored in a 'score table', which is passed to a series    of figure generation functions to produce CRCs, heatmaps, and scatter    plots (as requested by user).</p><pre>_____________      _____________      ______________      _____________
|             |    |             |    |              |    |             |
|  Acquire &amp;  |    |  Compute    |    |  Normalize / |    |  Produce    |
|  Organize   |---&gt;|  Phenotype  |---&gt;|  Compute     |---&gt;|  Figures &amp;  |
|  Input data |    |  Scores     |    |  Hit scores  |    |  Tables     |
|_____________|    |_____________|    |______________|    |_____________|</pre><p>The following documentation is organized mostly according to the same outline: 1. Examples of how to get data into AnalyzeHts() 2. Examples of how to request different scoring metrics    o This section is brief, see a more detailed treatment in      HtsScoringVignette.m 3. Examples of normalizations and hit-scoring    o This section is brief, see a more detailed treatment in      HtsNormalizationVignette.m 4. Examples showing how to control figure outputs 5. Some common use-cases, general examples</p><h2 id="3">%%%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%%</h2><p>1. Ways to get data into AnalyzeHts</p><h2 id="4">%%%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%%</h2><p>Fundamentally, AnalyzeHts works on feature tables, but there are several useful variations on getting feature tables into AnalyzeHts(), each of which may work for you in different contexts, depending on what you're trying to achieve.</p><h2 id="5">1.1 Pass in a feature table you've already got.</h2><p>Depending on your workflow, you may already have an SFT saved, either produced from AnalyzeProject() or downloaded from OptoDB.  If so, using AnalyzeHts() is as simple as loading that SFT in from the disk and passing it in as a name-value pair, like so:</p><pre class="codeinput"><span class="comment">% Load a feature table, 'sft_ucb', into memory</span>
sft_ucb = table();

a= 7;
b = a-4;
</pre><h2 id="6">1.2 Request a feature table from OptoDB as a part of HTS analysis</h2><p>If you don't already have an SFT, you can request one as a part of running the HTS analysis, and if you provide the correct information, AnalyzeHts() will go off and download it and then proceed with analysis. If your plates were barcoded, you can use the barcodes for all requested plates to request that SFT.  (To be specific here, to the software, your plates only count as being barcoded if the movies produced have a metadata field titled 'cellPlateBarcodes' and that field contains a string uniquely identifying each plate that gets loaded into OptoDB). For example, this first call should produce exactly the same figures as from &sect;1.1:</p><pre class="codeinput"><span class="comment">% load('S:\SoftwareTesting\testHtsOutputs\data\sft.mat')</span>
dd=12;
</pre><h2 id="7">1.3 Passing in an analyses object to do a time-bin analysis</h2><p>The AnalyzeHts() pipeline supports the Time-Bin analysis, originally developed by Kit.  In order to conduct this analysis, detailed information about the stimulation protocol and spike-timing is needed that isn't stored in source feature tables, so we have to compute that information from an analyses.savefast file for a given experiment.  A full discsusion of that code-base is outside the scope of this vignette, but see MakeTimeBinSpecification, BuildTimeBinTable, and ComputeTimeBinSsmdScores for more information. clearvars</p><pre class="codeinput">b-4
</pre><pre class="codeoutput">
ans =

    -1

</pre><h2 id="8">%%%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%%</h2><p>2. Different scoring functions</p><h2 id="9">%%%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%%</h2><p>AnalyzeHts() allows you to specify many different scoring functions which produce 'disease scores' or 'phenotype scores.'  Many of these functions have their own required parameters, so you have to be attentive to those requirements when requesting more scores.  I will discuss a few of these in detail here, and the remaining detail will be found in HtsScoringVignette.m.</p><p>All scoring functions are named "HtsScore_*.m" to make them easy to find. They all follow the following signature:   [htsData, scoreTable] = HtsScore_ScoreFcn( htsData, varargin )</p><p>So every scoring function receives htsData (a data structure containing all the data you have requested, so SFTs or time bin tables or aggregated versions thereof) and all the options, and returns a table of scores for every well.</p><p>A couple highlights:   * HtsScore_SelectColumns() - Allows you to specify individual parametric     features to get selected as scores.  Useful if your phenotype is well     described by features already in your feature table, or if it specifically     affects a small subset of features and you want to see figures for them     all.   * HtsScore_OverallLda() - Generates a composite score, combining several     user-specified features into one new column by a weighted average.     Weights set using a 'Linear Discriminant Analysis'</p><h2 id="10">2.1 Requesting multiple existing features using _SelectColumns()</h2><pre class="codeinput"><span class="comment">% Load in some data already aggregated to the well level</span>
<span class="comment">% (You can do this if you want to skip the aggregation step to speed things up</span>
<span class="comment">% in AnalyzeHts)</span>

<span class="comment">% Define a list of features you're interested in as a cell array of strings</span>
k=1;
</pre><h2 id="11">%%%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%%</h2><p>3. Examples of Normalization and Hit Scores</p><h2 id="12">%%%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%%</h2><h2 id="13">3.1 - on-plate NPI</h2><pre class="codeinput">a=5;
</pre><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2016b</a><br></p></div><!--
##### SOURCE BEGIN #####
% HtsVignette.m
%% Summary
% This document will outline the major features and functionality of the
% code-base developed at Q-State for the analysis of high-throughput
% screening data.  First I'll give a short narrative description of the
% major modules, and that will be followed by a series of examples
% outlining how major features are intended to be used.
% 
% In keeping with Q-State's historically boring (and descriptive) naming
% scheme, the primary function to call for generating HTS analyses is
% AnalyzeHts().  This pipeline was designed and built with HTS data in mind,
% but has turned out to be useful for a variety of phenotyping and
% drug-discovery analysis needs.  The basic design principle is to specify
% a set of disease scores, normalize them to any existing controls, and
% then generate plots for every specified score.
% 
% Below is a high-level diagram of the AnalyzeHts() pipeline.  Briefly, 
% 1. You give it some data (or tell it where to find said data), which it
%    cleans up and aggregates to the requested level (ie, by default a
%    source-feature table gets aggregated to the well level, since most
%    screens are presumed to operate at the well level)
% 2. It computes the descriptive scores you have requested (more detail on
%    this in HtsScoringVignette.m, but this could be anything from a single
%    feature, like Rheobase, to multi-parameter LDA scores, to automated
%    vector-decomposition or PCA-based scores).
% 3. These scores are optionally normalized and converted into 'hit scores'
%    (more information on this in HtsNormalizationVignette.m)
% 4. All scores are stored in a 'score table', which is passed to a series
%    of figure generation functions to produce CRCs, heatmaps, and scatter
%    plots (as requested by user).
% 
%  _____________      _____________      ______________      _____________
% |             |    |             |    |              |    |             |
% |  Acquire &  |    |  Compute    |    |  Normalize / |    |  Produce    |
% |  Organize   |REPLACE_WITH_DASH_DASH->|  Phenotype  |REPLACE_WITH_DASH_DASH->|  Compute     |REPLACE_WITH_DASH_DASH->|  Figures &  |
% |  Input data |    |  Scores     |    |  Hit scores  |    |  Tables     |
% |_____________|    |_____________|    |______________|    |_____________|
% 
% 
% The following documentation is organized mostly according to the same
% outline:
% 1. Examples of how to get data into AnalyzeHts()
% 2. Examples of how to request different scoring metrics
%    o This section is brief, see a more detailed treatment in
%      HtsScoringVignette.m
% 3. Examples of normalizations and hit-scoring
%    o This section is brief, see a more detailed treatment in
%      HtsNormalizationVignette.m
% 4. Examples showing how to control figure outputs
% 5. Some common use-cases, general examples

%% %%%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%%
% 1. Ways to get data into AnalyzeHts
%%% %%%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%%
% Fundamentally, AnalyzeHts works on feature tables, but there are several
% useful variations on getting feature tables into AnalyzeHts(), each of
% which may work for you in different contexts, depending on what you're
% trying to achieve.
% 
%% 1.1 Pass in a feature table you've already got.
% Depending on your workflow, you may already have an SFT saved, either
% produced from AnalyzeProject() or downloaded from OptoDB.  If so, using
% AnalyzeHts() is as simple as loading that SFT in from the disk and
% passing it in as a name-value pair, like so:

% Load a feature table, 'sft_ucb', into memory
sft_ucb = table();

a= 7;
b = a-4;


%% 1.2 Request a feature table from OptoDB as a part of HTS analysis
% If you don't already have an SFT, you can request one as a part of
% running the HTS analysis, and if you provide the correct information,
% AnalyzeHts() will go off and download it and then proceed with analysis.
% If your plates were barcoded, you can use the barcodes for all requested
% plates to request that SFT.  (To be specific here, to the software, your
% plates only count as being barcoded if the movies produced have a
% metadata field titled 'cellPlateBarcodes' and that field contains a
% string uniquely identifying each plate that gets loaded into OptoDB).
% For example, this first call should produce exactly the same figures as 
% from ยง1.1:

% load('S:\SoftwareTesting\testHtsOutputs\data\sft.mat')
dd=12;

%% 1.3 Passing in an analyses object to do a time-bin analysis
% The AnalyzeHts() pipeline supports the Time-Bin analysis, originally
% developed by Kit.  In order to conduct this analysis, detailed
% information about the stimulation protocol and spike-timing is needed
% that isn't stored in source feature tables, so we have to compute that
% information from an analyses.savefast file for a given experiment.  A
% full discsusion of that code-base is outside the scope of this vignette,
% but see MakeTimeBinSpecification, BuildTimeBinTable, and
% ComputeTimeBinSsmdScores for more information.
% clearvars

b-4

%% %%%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%%
% 2. Different scoring functions
%%% %%%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%%
% AnalyzeHts() allows you to specify many different scoring functions which
% produce 'disease scores' or 'phenotype scores.'  Many of these functions
% have their own required parameters, so you have to be attentive to those
% requirements when requesting more scores.  I will discuss a few of these
% in detail here, and the remaining detail will be found in
% HtsScoringVignette.m.  
% 
% All scoring functions are named "HtsScore_*.m" to make them easy to find.
% They all follow the following signature:
%   [htsData, scoreTable] = HtsScore_ScoreFcn( htsData, varargin )
% 
% So every scoring function receives htsData (a data structure containing
% all the data you have requested, so SFTs or time bin tables or aggregated
% versions thereof) and all the options, and returns a table of scores for
% every well.
% 
% A couple highlights:
%   * HtsScore_SelectColumns() - Allows you to specify individual parametric
%     features to get selected as scores.  Useful if your phenotype is well 
%     described by features already in your feature table, or if it specifically
%     affects a small subset of features and you want to see figures for them
%     all.
%   * HtsScore_OverallLda() - Generates a composite score, combining several
%     user-specified features into one new column by a weighted average.
%     Weights set using a 'Linear Discriminant Analysis'

%% 2.1 Requesting multiple existing features using _SelectColumns()

% Load in some data already aggregated to the well level
% (You can do this if you want to skip the aggregation step to speed things up
% in AnalyzeHts)

% Define a list of features you're interested in as a cell array of strings
k=1;

%% %%%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%%
% 3. Examples of Normalization and Hit Scores
%%% %%%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%% %%%
% 
%% 3.1 - on-plate NPI
a=5;

##### SOURCE END #####
--></body></html>